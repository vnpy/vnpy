# -*- coding: utf-8 -*-
"""
Defines the BaseStrategyEngine, the core component for managing and executing
trading strategies within the vn.py framework. It integrates portfolio
management capabilities via an optional PortfolioEngine.

Core Responsibilities:
- Loading strategy code modules and configuration settings.
- Managing the lifecycle of strategy instances (initialization, start, stop).
- Subscribing to necessary market data for strategies.
- Processing market events (e.g., factor updates) and triggering strategy logic.
- Handling order requests generated by strategies via a dedicated ExecutionAgent.
- Routing order and trade update events back to the relevant strategy instances.
- Providing utility functions for strategies to access market data, contract details,
  and portfolio state (if PortfolioEngine is active).
- Persisting strategy settings and optional runtime state.
"""

import importlib
import traceback
import os
import sys
import glob
from typing import Type, Callable, Dict, List, Optional, Any, Tuple, Set, Union
from datetime import datetime, timezone, date
from concurrent.futures import ThreadPoolExecutor
from logging import INFO, ERROR, DEBUG, WARNING  # Standard logging levels
from pathlib import Path
from types import ModuleType

# --- VnTrader Core Imports ---
from vnpy.event import Event, EventEngine
from vnpy.strategy.base import EVENT_PORTFOLIO_STRATEGY
from vnpy.trader.engine import BaseEngine, MainEngine
from vnpy.trader.object import (
    OrderRequest, SubscribeRequest, CancelRequest,
    LogData, TickData, OrderData, TradeData, BarData, ContractData
)
from vnpy.trader.event import (
    EVENT_ORDER, EVENT_TRADE, EVENT_CONTRACT, EVENT_TIMER, EVENT_LOG,
    EVENT_FACTOR
)
from vnpy.trader.constant import EngineType
from vnpy.trader.utility import load_json, save_json, get_file_path, virtual
from vnpy.trader.database import BaseDatabase, get_database
from vnpy.trader.datafeed import BaseDatafeed, get_datafeed
from vnpy.strategy.settings import get_strategy_definitions_filepath, get_strategy_setting, STRATEGY_MODULE_SETTINGS
import pandas as pd # For DataFrame operations

# --- Strategy & Portfolio Specific Imports ---
# Assumes portfolio_manager is accessible (e.g., sibling directory or installed)
from vnpy.app.portfolio_manager.engine import PortfolioEngine, APP_NAME as PortfolioEngine_APP_NAME

PORTFOLIO_APP_NAME = PortfolioEngine_APP_NAME

from vnpy.strategy.execution_agent import ExecutionAgent
from vnpy.factor.memory import FactorMemory # Added
from vnpy.strategy.template import StrategyTemplate

# --- Constants ---
STRATEGY_ENGINE_APP_NAME: str = "StrategyEngine"  # Default unique name for this engine
# DEFAULT_STRATEGIES_DIR is now handled by STRATEGY_MODULE_SETTINGS
# DEFAULT_EXECUTION_GATEWAY is now handled by STRATEGY_MODULE_SETTINGS

# Filename Templates
# SETTING_FILENAME_TPL is replaced by definitions_filepath
STRATEGY_DATA_FILENAME_TPL: str = "strategy_data_{}.json"  # Template for strategy runtime data

# Event Types
EVENT_STRATEGY_LOG = EVENT_LOG  # Use standard log event type
EVENT_STRATEGY_UPDATE = EVENT_PORTFOLIO_STRATEGY  # Use standard strategy update event type


class BaseStrategyEngine(BaseEngine):
    """
    Core engine for loading, managing the lifecycle, and executing trading
    strategies derived from `StrategyTemplate`. Integrates with an optional
    `PortfolioEngine` for PnL and position tracking.
    """

    # Engine type can be overridden by MainEngine in backtesting mode
    engine_type: EngineType = EngineType.LIVE

    def __init__(
            self,
            main_engine: MainEngine,
            event_engine: EventEngine,
            engine_name: str = STRATEGY_ENGINE_APP_NAME
    ) -> None:
        """
        Initialize the BaseStrategyEngine.

        Args:
            main_engine: The main trading engine instance.
            event_engine: The central event engine instance.
            engine_name: A unique name for this engine instance.
        """
        super().__init__(main_engine, event_engine, engine_name=engine_name)

        # --- Load Configuration from Settings ---
        strategies_dir_default = "vnpy/strategy/examples"  # Default if not in settings
        strategies_dir_from_settings = STRATEGY_MODULE_SETTINGS.get("default_strategy_path", strategies_dir_default)
        self.strategies_path: Path = Path.cwd().joinpath(strategies_dir_from_settings)

        self.execution_gateway_name = STRATEGY_MODULE_SETTINGS.get("default_execution_gateway", "BINANCE_SPOT")
        
        self.definitions_filepath: Path = get_strategy_definitions_filepath()

        self.write_log(f"Engine Name: {self.engine_name}", level=DEBUG)
        self.write_log(f"Strategies Code Directory: {self.strategies_path}", level=INFO)
        self.write_log(f"Execution Gateway: {self.execution_gateway_name}", level=INFO)
        self.write_log(f"Strategy Definitions File: {self.definitions_filepath}", level=INFO)

        # --- Core Strategy State ---
        self.strategy_classes: Dict[str, Type[StrategyTemplate]] = {}  # {ClassName: Class}
        self.strategies: Dict[str, StrategyTemplate] = {}  # {StrategyName: Instance}
        self.strategy_settings: Dict[str, dict] = {}  # {StrategyName: SettingDict} Loaded from file

        # --- Supporting Components ---
        self.database: BaseDatabase = get_database()
        self.datafeed: BaseDatafeed = get_datafeed()
        self.execution_agent: ExecutionAgent = self._init_execution_agent()
        self.portfolio_engine: Optional[PortfolioEngine] = self._init_portfolio_engine()

        # --- Asynchronous Operations ---
        self.init_executor: ThreadPoolExecutor = ThreadPoolExecutor(
            max_workers=1, thread_name_prefix=f"{self.engine_name}_Init"
        )

        # --- Factor Handling ---
        self.latest_factors: Dict[str, Any] = {} # Will be deprecated in process_factor_event
        self.factor_update_time: Optional[datetime] = None
        self.latest_factor_memories: Dict[str, "FactorMemory"] = {} # Added

        self.write_log("Engine initialization started.", level=DEBUG)

    def _init_execution_agent(self) -> ExecutionAgent:
        """Initialize the ExecutionAgent."""
        self.write_log(f"Initializing ExecutionAgent for gateway: {self.execution_gateway_name}", level=INFO)
        try:
            if not callable(ExecutionAgent) or ExecutionAgent.__name__ == 'object':  # Check if it's the dummy
                raise ImportError("ExecutionAgent class is not valid or not imported.")
            agent = ExecutionAgent(
                main_engine=self.main_engine,
                gateway_name=self.execution_gateway_name
            )
            self.write_log("ExecutionAgent initialized successfully.", level=INFO)
            return agent
        except Exception as e:
            self.write_log(f"FATAL: Failed to initialize ExecutionAgent: {e}\n{traceback.format_exc()}", level=ERROR)
            print(f"FATAL ERROR in {self.engine_name}: ExecutionAgent failed. Order functionality disabled.")

            class DummyExecutionAgent:
                def send_order(self, req: OrderRequest, lock: bool, net: bool) -> List[str]: self.log_error(
                    req); return []

                def cancel_order(self, req: Union[CancelRequest, OrderData]) -> None: self.log_error(req)

                def log_error(self, req): print(f"ERROR: ExecutionAgent not initialized. Cannot process request: {req}")

            return DummyExecutionAgent()

    def _init_portfolio_engine(self) -> Optional[PortfolioEngine]:
        """Initialize the PortfolioEngine if available."""
        if PortfolioEngine:  # Check if class was imported successfully
            self.write_log(f"Initializing PortfolioEngine ('{PORTFOLIO_APP_NAME}')...", level=INFO)
            try:
                portfolio_engine = PortfolioEngine(self.main_engine, self.event_engine)
                self.write_log(f"PortfolioEngine ('{PORTFOLIO_APP_NAME}') initialized successfully.", level=INFO)
                return portfolio_engine
            except Exception as e:
                self.write_log(f"Failed to initialize PortfolioEngine: {e}\n{traceback.format_exc()}", level=ERROR)
                return None
        else:
            self.write_log("PortfolioEngine class not available. Portfolio management disabled.", level=WARNING)
            return None

    # --------------------------------
    # Engine Lifecycle
    # --------------------------------

    def init_engine(self, *args, **kwargs) -> None:
        """Initialize the engine: Load components, strategies, settings, data, and register events."""
        self.write_log("Initializing Strategy Engine components...")
        try:
            self.init_datafeed()
            # self.load_all_strategy_classes(args=args, kwargs=kwargs)
            # self.load_all_strategy_settings()
            # self.create_strategies_from_settings()
            # self.load_all_strategy_data()

            if kwargs.get("strategies"):
                self.strategies = kwargs.get("strategies")
            self.register_event()
            self.write_log(f"{self.engine_name} initialization complete. "
                           f"{len(self.strategies)} strategies loaded. "
                           f"Portfolio Management: {'ENABLED' if self.portfolio_engine else 'DISABLED'}", level=INFO)
        except Exception as e:
            self.write_log(f"CRITICAL ERROR during engine initialization: {e}\n{traceback.format_exc()}", level=ERROR)

    def init_datafeed(self) -> None:
        """Initialize the data feed connection."""
        self.write_log("Initializing datafeed...", level=INFO)
        try:
            logger_callback = lambda msg: self.write_log(f"[DataFeed] {msg}", level=DEBUG)
            result: bool = self.datafeed.init(logger_callback)
            if result:
                self.write_log("Datafeed initialized successfully.", level=INFO)
            else:
                self.write_log("Datafeed initialization failed (returned False). Check datafeed logs.", level=WARNING)
        except Exception as e:
            self.write_log(f"Exception during datafeed initialization: {e}", level=ERROR)

    def register_event(self) -> None:
        """Register event listeners required by the StrategyEngine."""
        self.write_log("Registering engine event listeners...", level=DEBUG)
        try:
            self.event_engine.register(EVENT_ORDER, self.process_order_event)
            self.event_engine.register(EVENT_TRADE, self.process_trade_event)
            self.event_engine.register(EVENT_FACTOR, self.process_factor_event)
            self.event_engine.register(EVENT_TIMER, self._process_timer_event) # Added
            self.write_log("Engine event listeners registered.", level=DEBUG)
        except Exception as e:
            self.write_log(f"Error registering engine events: {e}", level=ERROR)

    def close(self) -> None:
        """Cleanly shut down the engine and its components."""
        self.write_log(f"Shutting down {self.engine_name}...")
        self.stop_all_strategies()
        if self.portfolio_engine:
            try:
                self.portfolio_engine.close()
                self.write_log(f"PortfolioEngine ('{PORTFOLIO_APP_NAME}') closed.", level=INFO)
            except Exception as e:
                self.write_log(f"Error closing PortfolioEngine: {e}\n{traceback.format_exc()}", level=ERROR)
        self.unregister_event()
        self.write_log("Shutting down init executor...", level=DEBUG)
        self.init_executor.shutdown(wait=True)
        self.write_log("Init executor shut down.", level=DEBUG)
        self.write_log(f"{self.engine_name} shut down complete.", level=INFO)

    def unregister_event(self) -> None:
        """Unregister event listeners used by the StrategyEngine."""
        self.write_log("Unregistering engine event listeners...", level=DEBUG)
        try:
            self.event_engine.unregister(EVENT_ORDER, self.process_order_event)
            self.event_engine.unregister(EVENT_TRADE, self.process_trade_event)
            self.event_engine.unregister(EVENT_FACTOR, self.process_factor_event)
            self.event_engine.unregister(EVENT_TIMER, self._process_timer_event) # Added
            self.write_log("Engine event listeners unregistered.", level=DEBUG)
        except Exception as e:
            self.write_log(f"Error unregistering engine events: {e}", level=ERROR)

    # --------------------------------
    # Strategy Loading and Settings
    # --------------------------------

    def load_all_strategy_classes(self, *args, **kwargs) -> None:
        """Scan the strategies directory and load all found strategy classes."""

        if kwargs.get("strategies_path", ""):
            self.strategies_path = kwargs.get("strategies_path", "")
        self.write_log(f"Loading strategy classes from directory: {self.strategies_path}", level=INFO)
        if not self.strategies_path.is_dir():
            self.write_log(f"Strategies directory not found or is not a directory: {self.strategies_path}", level=ERROR)
            return

        initial_class_count = len(self.strategy_classes)
        module_prefix = self.strategies_path.name

        for suffix in ["py", "pyd", "so"]:
            pathname = str(self.strategies_path.joinpath(f"*.{suffix}"))
            for filepath in glob.glob(pathname):
                module_path = Path(filepath)
                stem = module_path.stem
                if stem.startswith("_"): continue

                strategy_module_name = f"{module_prefix}.{stem}"
                try:
                    self._load_strategy_class_from_module(strategy_module_name)
                except ImportError:
                    self.write_log(
                        f"Relative import failed for {strategy_module_name}, trying direct import of '{stem}'...",
                        level=DEBUG)
                    try:
                        self._load_strategy_class_from_module(stem)
                    except ImportError as e:
                        self.write_log(f"Direct import also failed for '{stem}': {e}", level=ERROR)

        loaded_count = len(self.strategy_classes) - initial_class_count
        self.write_log(
            f"Finished loading strategy classes. Found {loaded_count} new classes. Total: {len(self.strategy_classes)}",
            level=INFO)

    def _load_strategy_class_from_module(self, module_name: str) -> int:
        """Load strategy classes from a specific module file, handling reload."""
        count = 0
        try:
            module_to_load: ModuleType
            if module_name in sys.modules:
                module_to_load = importlib.reload(sys.modules[module_name])
                self.write_log(f"Reloaded strategy module: {module_name}", level=DEBUG)
            else:
                module_to_load = importlib.import_module(module_name)
                self.write_log(f"Imported strategy module: {module_name}", level=DEBUG)

            for name in dir(module_to_load):
                value = getattr(module_to_load, name)
                if (isinstance(value, type) and issubclass(value, StrategyTemplate) and value is not StrategyTemplate):
                    class_name = value.__name__
                    if class_name in self.strategy_classes and self.strategy_classes[class_name] is not value:
                        self.write_log(
                            f"Warning: Strategy class '{class_name}' from '{module_name}' conflicts with existing class. Skipping.",
                            level=WARNING)
                        continue
                    if class_name not in self.strategy_classes:
                        self.strategy_classes[class_name] = value
                        count += 1
                        self.write_log(f"Loaded strategy class: '{class_name}' from '{module_name}'", level=DEBUG)
            return count
        except ModuleNotFoundError:
            self.write_log(f"Module '{module_name}' not found.", level=DEBUG)
            raise
        except Exception:
            self.write_log(f"Failed to load strategy class from module '{module_name}':\n{traceback.format_exc()}",
                           level=ERROR)
            return 0

    def load_all_strategy_settings(self) -> None:
        """Load strategy settings from the definitions JSON file."""
        self.write_log(f"Loading strategy instance definitions from: {self.definitions_filepath}", level=INFO)
        
        loaded_data = load_json(self.definitions_filepath)
        transformed_settings: Dict[str, dict] = {}

        if isinstance(loaded_data, list):
            # Original format: list of template definitions
            self.write_log(f"Detected list format in {self.definitions_filepath}, transforming to instance dictionary.", level=INFO)
            for i, template_def in enumerate(loaded_data):
                if not isinstance(template_def, dict):
                    self.write_log(f"Skipping invalid template definition (not a dict) at index {i}.", level=WARNING)
                    continue

                class_name = template_def.get("class_name")
                if not class_name:
                    self.write_log(f"Skipping template definition at index {i} due to missing 'class_name'.", level=WARNING)
                    continue

                parameters = template_def.get("parameters", {})
                vt_symbols = parameters.get("vt_symbols", []) # Assuming vt_symbols is within parameters

                # Generate a unique strategy instance name
                # Priority: strategy_instance_name > template_name > class_name
                strategy_instance_name = template_def.get("strategy_instance_name")
                if not strategy_instance_name:
                    template_name = template_def.get("template_name", class_name)
                    strategy_instance_name = f"{template_name}_Instance_{i+1}"
                
                if strategy_instance_name in transformed_settings:
                    self.write_log(f"Duplicate strategy instance name '{strategy_instance_name}' generated/found. Appending counter.", level=WARNING)
                    strategy_instance_name = f"{strategy_instance_name}_{i+1}"

                transformed_settings[strategy_instance_name] = {
                    "class_name": class_name,
                    "vt_symbols": vt_symbols,
                    "setting": parameters  # The whole "parameters" dict from template_def
                }
            self.strategy_settings = transformed_settings
            self.write_log(f"Transformed {len(transformed_settings)} strategy templates into instance settings.", level=INFO)
            # Consider saving back in the new dict format immediately or on close
            # self.save_all_strategy_settings() 
        elif isinstance(loaded_data, dict):
            # New format: dictionary of instance configurations
            self.strategy_settings = loaded_data
            self.write_log(f"Loaded {len(self.strategy_settings)} strategy instance configurations directly from {self.definitions_filepath}.", level=INFO)
        elif loaded_data is None and not self.definitions_filepath.exists():
             self.write_log(f"Strategy definitions file {self.definitions_filepath} not found. Initializing with empty settings.", level=INFO)
             self.strategy_settings = {}
        else:
            self.write_log(
                f"Invalid data format in '{self.definitions_filepath}': Expected a list or dictionary, got {type(loaded_data)}. Initializing with empty settings.",
                level=ERROR)
            self.strategy_settings = {}

    def create_strategies_from_settings(self) -> None:
        """Instantiate strategy objects based on the loaded settings."""
        self.write_log("Creating strategy instances from settings...", level=INFO)
        created_count = 0
        invalid_settings_names = []

        for strategy_name, setting in self.strategy_settings.items():
            if not self._validate_setting_entry(strategy_name, setting):
                invalid_settings_names.append(strategy_name)
                continue
            class_name = setting["class_name"]
            vt_symbols = setting["vt_symbols"]
            strategy_params = setting["setting"]

            if self.add_strategy(class_name, strategy_name, vt_symbols, strategy_params):
                created_count += 1
            else:
                invalid_settings_names.append(strategy_name)

        if invalid_settings_names:
            for name in invalid_settings_names:
                self.strategy_settings.pop(name, None)
            self.write_log(
                f"Removed {len(invalid_settings_names)} invalid or failed strategy settings from runtime config.",
                level=WARNING)

        self.write_log(f"Finished creating strategy instances. Successful: {created_count}", level=INFO)

    def _validate_setting_entry(self, strategy_name: str, setting: Any) -> bool:
        """Perform basic validation on a single strategy setting entry."""
        if not isinstance(setting, dict):
            self.write_log(f"Invalid setting for '{strategy_name}': Entry must be a dictionary.", level=WARNING)
            return False
        required_keys = {"class_name", "vt_symbols", "setting"}
        if not required_keys.issubset(setting.keys()):
            self.write_log(
                f"Invalid setting for '{strategy_name}': Missing required keys: {required_keys - set(setting.keys())}.",
                level=WARNING)
            return False
        class_name = setting["class_name"]
        if not isinstance(class_name, str) or not class_name:
            self.write_log(f"Invalid setting for '{strategy_name}': 'class_name' must be a non-empty string.",
                           level=WARNING)
            return False
        if not isinstance(setting["vt_symbols"], list):
            self.write_log(f"Invalid setting for '{strategy_name}': 'vt_symbols' must be a list.", level=WARNING)
            return False
        if not isinstance(setting["setting"], dict):
            self.write_log(f"Invalid setting for '{strategy_name}': 'setting' (parameters) must be a dictionary.",
                           level=WARNING)
            return False
        if class_name not in self.strategy_classes:
            self.write_log(f"Invalid setting for '{strategy_name}': Strategy class '{class_name}' is not loaded.",
                           level=WARNING)
            return False
        return True

    def save_all_strategy_settings(self) -> None:
        """Save the current configuration of all active strategies to the definitions file."""
        self.write_log(f"Saving strategy instance configurations to: {self.definitions_filepath}", level=DEBUG)
        settings_to_save: Dict[str, dict] = {}
        for strategy_name, strategy in self.strategies.items():
            try:
                settings_to_save[strategy_name] = self._get_strategy_setting_dict(strategy)
            except Exception as e:
                self.write_log(f"Error preparing settings for strategy '{strategy_name}' for saving: {e}", level=ERROR,
                               strategy=strategy)

        # The definitions_filepath is already a Path object
        if save_json(self.definitions_filepath, settings_to_save):
            self.write_log(f"Saved configurations for {len(settings_to_save)} strategy instances to {self.definitions_filepath}", level=INFO)
        else:
            self.write_log(f"Failed to save strategy instance configurations to {self.definitions_filepath} (save_json returned False)", level=ERROR)

    def _get_strategy_setting_dict(self, strategy: StrategyTemplate) -> dict:
        """Create the dictionary representation of a strategy's settings for saving."""
        if not hasattr(strategy, 'get_parameters') or not callable(strategy.get_parameters):
            raise AttributeError(f"Strategy '{strategy.strategy_name}' missing 'get_parameters' method.")
        strategy_params = strategy.get_parameters()
        strategy_params['vt_symbols'] = strategy.vt_symbols
        strategy_params['class_name'] = strategy.__class__.__name__
        setting_dict = {
            "class_name": strategy_params.pop('class_name'),
            "vt_symbols": strategy_params.pop('vt_symbols'),
            "setting": strategy_params
        }
        return setting_dict

    def update_strategy_setting_cache(self, strategy_name: str) -> None:
        """Update the internal settings cache (self.strategy_settings) for a single strategy."""
        if strategy_name not in self.strategies:
            self.write_log(f"Cannot update settings cache: Strategy '{strategy_name}' not found.", level=ERROR)
            return
        strategy = self.strategies[strategy_name]
        try:
            self.strategy_settings[strategy_name] = self._get_strategy_setting_dict(strategy)
            self.write_log(f"Updated internal settings cache for strategy: {strategy_name}", level=DEBUG)
        except Exception as e:
            self.write_log(f"Error updating settings cache for strategy '{strategy_name}': {e}", level=ERROR,
                           strategy=strategy)

    def remove_strategy_setting_cache(self, strategy_name: str) -> None:
        """Remove a strategy's setting from the internal cache. Does NOT save to file."""
        if strategy_name in self.strategy_settings:
            if self.strategy_settings.pop(strategy_name, None):
                self.write_log(f"Removed setting for strategy '{strategy_name}' from internal cache.", level=DEBUG)

    # --------------------------------
    # Strategy Runtime Data Management
    # --------------------------------
    @virtual
    def load_all_strategy_data(self) -> None:
        """Load runtime data for all strategy instances that implement `load_data`."""
        self.write_log("Loading strategy runtime data...", level=INFO)
        loaded_count = 0
        for strategy_name in list(self.strategies.keys()):
            if strategy_name in self.strategies:
                strategy = self.strategies[strategy_name]
                if self._load_single_strategy_data(strategy):
                    loaded_count += 1
        self.write_log(f"Finished loading runtime data. Loaded for {loaded_count} strategies.", level=INFO)

    def _load_single_strategy_data(self, strategy: StrategyTemplate) -> bool:
        """Load runtime data for a single strategy instance if supported."""
        if not (hasattr(strategy, 'load_data') and callable(strategy.load_data)):
            return False
        strategy_name = strategy.strategy_name
        data_filename = STRATEGY_DATA_FILENAME_TPL.format(strategy_name)
        filepath = get_file_path(data_filename)
        if not filepath.exists():
            self.write_log(f"No runtime data file found for strategy: {strategy_name} at {filepath}", level=DEBUG,
                           strategy=strategy)
            return False
        try:
            strategy_data = load_json(filepath)
            if strategy_data:
                self.write_log(f"Attempting to load runtime data into strategy: {strategy_name}", level=DEBUG,
                               strategy=strategy)
                strategy.load_data(strategy_data)
                self.write_log(f"Successfully loaded runtime data for strategy: {strategy_name}", level=INFO,
                               strategy=strategy)
                return True
            else:
                self.write_log(f"Runtime data file for strategy {strategy_name} is empty or invalid JSON at {filepath}",
                               level=WARNING, strategy=strategy)
                return False
        except Exception:
            self.write_log(f"Error occurred within {strategy_name}.load_data() method:\n{traceback.format_exc()}",
                           level=ERROR, strategy=strategy)
            return False

    @virtual
    def save_strategy_data(self, strategy_name: str) -> bool:
        """Save runtime data for a specific strategy instance if supported."""
        if strategy_name not in self.strategies:
            self.write_log(f"Cannot save data: Strategy '{strategy_name}' not found.", level=ERROR)
            return False
        strategy = self.strategies[strategy_name]
        if not (hasattr(strategy, 'get_data') and callable(strategy.get_data)):
            self.write_log(f"Strategy '{strategy_name}' does not implement get_data(). Cannot save runtime data.",
                           level=DEBUG, strategy=strategy)
            return False
        data_filename = STRATEGY_DATA_FILENAME_TPL.format(strategy_name)
        filepath = get_file_path(data_filename)
        try:
            strategy_data = strategy.get_data()
            if not isinstance(strategy_data, dict):
                self.write_log(
                    f"Strategy '{strategy_name}' get_data() did not return a dictionary (returned {type(strategy_data)}). Cannot save.",
                    level=WARNING, strategy=strategy)
                return False
            self.write_log(f"Saving runtime data for strategy: {strategy_name} to {filepath}", level=DEBUG,
                           strategy=strategy)
            if save_json(filepath, strategy_data):
                return True
            else:
                self.write_log(f"Failed to save runtime data for strategy {strategy_name} (save_json returned False)",
                               level=ERROR, strategy=strategy)
                return False
        except Exception:
            self.write_log(f"Error occurred within {strategy_name}.get_data() method:\n{traceback.format_exc()}",
                           level=ERROR, strategy=strategy)
            return False

    def save_all_strategy_data(self) -> None:
        """Save runtime data for all active strategies that support it."""
        self.write_log("Saving runtime data for all strategies...", level=DEBUG)
        saved_count = 0
        for strategy_name in list(self.strategies.keys()):
            if strategy_name in self.strategies:
                if self.save_strategy_data(strategy_name):
                    saved_count += 1
        self.write_log(f"Finished saving runtime data. Saved for {saved_count} strategies.", level=INFO)

    # --------------------------------
    # Strategy Instance Management (Add, Edit, Remove)
    # --------------------------------
    def add_strategy(self, class_name: str, strategy_name: str, vt_symbols: List[str], setting: dict) -> bool:
        """Create, validate, and add a new strategy instance."""
        if not isinstance(strategy_name, str) or not strategy_name:
            self.write_log("Add failed: Strategy name must be a non-empty string.", level=ERROR)
            return False
        if strategy_name in self.strategies:
            self.write_log(f"Add failed: Strategy name '{strategy_name}' already exists.", level=ERROR)
            return False
        strategy_class = self.strategy_classes.get(class_name)
        if not strategy_class:
            self.write_log(f"Add failed for '{strategy_name}': Strategy class '{class_name}' not found.", level=ERROR)
            return False
        if not isinstance(vt_symbols, list):
            self.write_log(f"Add failed for '{strategy_name}': vt_symbols must be a list.", level=ERROR)
            return False
        if not isinstance(setting, dict):
            self.write_log(f"Add failed for '{strategy_name}': setting (parameters) must be a dictionary.", level=ERROR)
            return False
        try:
            self.write_log(f"Instantiating strategy '{strategy_name}' from class '{class_name}'...", level=DEBUG)
            strategy = strategy_class(self, strategy_name, vt_symbols, setting)
            if not hasattr(strategy, 'get_parameters') or not callable(strategy.get_parameters):
                raise TypeError("Instantiated strategy object missing required 'get_parameters' method.")
        except Exception:
            self.write_log(
                f"Failed to instantiate or validate strategy '{strategy_name}' from class '{class_name}':\n{traceback.format_exc()}",
                level=ERROR)
            return False
        self.strategies[strategy_name] = strategy
        self.update_strategy_setting_cache(strategy_name)
        self.write_log(f"Strategy '{strategy_name}' (Class: '{class_name}') added successfully.", level=INFO,
                       strategy=strategy)
        self.put_strategy_update_event(strategy)
        return True

    def edit_strategy(self, strategy_name: str, setting: dict) -> bool:
        """Update parameters of an existing, stopped strategy instance. Saves settings."""
        if strategy_name not in self.strategies:
            self.write_log(f"Edit failed: Strategy '{strategy_name}' not found.", level=ERROR)
            return False
        strategy = self.strategies[strategy_name]
        if strategy.trading:
            self.write_log(f"Edit failed: Strategy '{strategy_name}' is currently running. Stop it before editing.",
                           level=WARNING, strategy=strategy)
            return False
        if not isinstance(setting, dict):
            self.write_log(f"Edit failed for '{strategy_name}': New setting must be a dictionary.", level=ERROR)
            return False
        if not (hasattr(strategy, 'update_setting') and callable(strategy.update_setting)):
            self.write_log(
                f"Edit failed: Strategy class '{strategy.__class__.__name__}' does not implement 'update_setting'.",
                level=ERROR, strategy=strategy)
            return False
        try:
            self.write_log(f"Applying parameter updates to strategy '{strategy_name}'...", level=DEBUG,
                           strategy=strategy)
            strategy.update_setting(setting)
            self.update_strategy_setting_cache(strategy_name)
            self.save_all_strategy_settings()
            self.write_log(
                f"Strategy '{strategy_name}' parameters updated and settings saved. Re-initialize the strategy to use new parameters.",
                level=INFO, strategy=strategy)
            self.put_strategy_update_event(strategy)
            return True
        except Exception:
            self.write_log(f"Error applying settings update to strategy '{strategy_name}':\n{traceback.format_exc()}",
                           level=ERROR, strategy=strategy)
            return False

    def remove_strategy(self, strategy_name: str, remove_data_file: bool = False) -> bool:
        """Remove a stopped strategy instance. Saves settings. Optionally removes data."""
        if strategy_name not in self.strategies:
            self.write_log(f"Remove failed: Strategy '{strategy_name}' not found.", level=WARNING)
            return False
        strategy = self.strategies[strategy_name]
        if strategy.trading:
            self.write_log(f"Remove failed: Strategy '{strategy_name}' is currently running. Stop it first.",
                           level=ERROR, strategy=strategy)
            return False
        self.write_log(f"Removing strategy '{strategy_name}'...", level=INFO, strategy=strategy)
        if hasattr(strategy, 'on_stop') and callable(strategy.on_stop):
            self.write_log(f"Ensuring on_stop is called for '{strategy_name}' during removal.", level=DEBUG,
                           strategy=strategy)
            self.call_strategy_func(strategy, strategy.on_stop)
        removed_strategy = self.strategies.pop(strategy_name, None)
        if removed_strategy:
            self.remove_strategy_setting_cache(strategy_name)
            self.save_all_strategy_settings()
            if remove_data_file:
                data_filename = STRATEGY_DATA_FILENAME_TPL.format(strategy_name)
                filepath = get_file_path(data_filename)
                try:
                    if filepath.exists():
                        os.remove(filepath)
                        self.write_log(f"Removed runtime data file: {filepath}", level=INFO)
                except OSError as e:
                    self.write_log(f"Error removing runtime data file {filepath}: {e}", level=WARNING)
            self.put_strategy_update_event(removed_strategy, removed=True)
            self.write_log(f"Strategy '{strategy_name}' removed successfully.", level=INFO)
            return True
        else:
            self.write_log(f"Internal error during removal of strategy '{strategy_name}'.", level=ERROR)
            return False

    # --------------------------------
    # Strategy Lifecycle Control (Init, Start, Stop)
    # --------------------------------
    def init_strategy(self, strategy_name: str) -> None:
        """Asynchronously initialize a strategy instance."""
        if strategy_name not in self.strategies:
            self.write_log(f"Init request ignored: Strategy '{strategy_name}' not found.", level=ERROR)
            return
        strategy = self.strategies[strategy_name]
        if strategy.inited:
            self.write_log(f"Init request ignored: Strategy '{strategy_name}' is already initialized.", level=DEBUG,
                           strategy=strategy)
            return
        self.write_log(f"Queueing initialization for strategy: {strategy_name}", level=INFO, strategy=strategy)
        self.init_executor.submit(self._init_strategy_thread, strategy_name)

    def _init_strategy_thread(self, strategy_name: str) -> None:
        """[Internal] Worker thread function for initializing a single strategy."""
        if strategy_name not in self.strategies:
            self.write_log(f"Init aborted: Strategy '{strategy_name}' removed before initialization started.",
                           level=WARNING)
            return
        strategy = self.strategies[strategy_name]
        if strategy.inited:  # Double check within thread
            self.write_log(f"Init aborted: Strategy '{strategy_name}' was already initialized by another thread.",
                           level=DEBUG, strategy=strategy)
            return
        self.write_log(f"Starting initialization process for: {strategy_name}", level=INFO, strategy=strategy)
        init_success = False
        try:
            self._load_single_strategy_data(strategy)
            if not self._subscribe_strategy_data(strategy):
                raise RuntimeError("Market data subscription failed.")
            if hasattr(strategy, 'on_init') and callable(strategy.on_init):
                self.write_log(f"Calling {strategy_name}.on_init()...", level=DEBUG, strategy=strategy)
                self.call_strategy_func(strategy, strategy.on_init)
                if not strategy.inited:
                    raise RuntimeError("Strategy on_init logic failed or did not set 'inited' flag.")
            else:
                strategy.inited = True
                self.write_log(
                    f"Strategy '{strategy_name}' has no on_init method, marked as initialized after subscriptions.",
                    level=DEBUG, strategy=strategy)
            init_success = True
            self.write_log(f"Strategy '{strategy_name}' initialized successfully.", level=INFO, strategy=strategy)
        except Exception as e:
            strategy.inited = False
            self.write_log(f"Initialization failed for strategy '{strategy_name}': {e}", level=ERROR, strategy=strategy)
            self._unsubscribe_strategy_data(strategy)
        finally:
            self.put_strategy_update_event(strategy)

    def _subscribe_strategy_data(self, strategy: StrategyTemplate) -> bool:
        """[Internal] Subscribe to market data required by the strategy."""
        self.write_log(f"Subscribing market data for '{strategy.strategy_name}': {strategy.vt_symbols}", level=DEBUG,
                       strategy=strategy)
        all_subs_successful = True
        subscribed_count = 0
        if not strategy.vt_symbols:
            self.write_log(f"No vt_symbols defined for strategy '{strategy.strategy_name}'. Skipping subscription.",
                           level=DEBUG, strategy=strategy)
            return True
        for vt_symbol in strategy.vt_symbols:
            contract = self.get_contract(vt_symbol)
            if not contract:
                self.write_log(f"Subscription failed for {vt_symbol}: Contract details not found.", level=ERROR,
                               strategy=strategy)
                all_subs_successful = False;
                continue
            gateway_name = contract.gateway_name
            if not gateway_name:
                self.write_log(f"Subscription failed for {vt_symbol}: Contract has no associated gateway name.",
                               level=ERROR, strategy=strategy)
                all_subs_successful = False;
                continue
            req = SubscribeRequest(symbol=contract.symbol, exchange=contract.exchange)
            try:
                self.write_log(f"Sending subscription request: {req} via gateway '{gateway_name}'", level=DEBUG,
                               strategy=strategy)
                self.main_engine.subscribe(req, gateway_name)
                subscribed_count += 1
            except Exception as e:
                self.write_log(f"Subscription request failed for {vt_symbol} on gateway {gateway_name}: {e}",
                               level=ERROR, strategy=strategy)
                all_subs_successful = False
        if subscribed_count > 0:
            self.write_log(
                f"Sent subscription requests for {subscribed_count}/{len(strategy.vt_symbols)} symbols for '{strategy.strategy_name}'.",
                level=INFO, strategy=strategy)
        if not all_subs_successful:
            self.write_log(f"One or more market data subscriptions failed for '{strategy.strategy_name}'. Check logs.",
                           level=WARNING, strategy=strategy)
        return all_subs_successful

    def _unsubscribe_strategy_data(self, strategy: StrategyTemplate) -> None:
        """[Internal] Placeholder for unsubscribing market data for a strategy."""
        self.write_log(
            f"Note: Unsubscribing data for '{strategy.strategy_name}' relies on gateway behavior or manual intervention.",
            level=DEBUG)
        pass

    @virtual
    def start_strategy(self, strategy_name: str) -> None:
        """Start trading for an initialized strategy."""
        if strategy_name not in self.strategies:
            self.write_log(f"Start failed: Strategy '{strategy_name}' not found.", level=ERROR);
            return
        strategy = self.strategies[strategy_name]
        if not strategy.inited:
            self.write_log(f"Start failed: Strategy '{strategy_name}' must be initialized first.", level=WARNING,
                           strategy=strategy);
            return
        if strategy.trading:
            self.write_log(f"Start ignored: Strategy '{strategy_name}' is already trading.", level=DEBUG,
                           strategy=strategy);
            return
        self.write_log(f"Starting strategy: {strategy_name}", level=INFO, strategy=strategy)
        start_success = False
        try:
            if hasattr(strategy, 'on_start') and callable(strategy.on_start):
                self.write_log(f"Calling {strategy_name}.on_start()...", level=DEBUG, strategy=strategy)
                self.call_strategy_func(strategy, strategy.on_start)
                if strategy.trading: start_success = True
            else:
                strategy.trading = True;
                start_success = True
                self.write_log(f"Strategy '{strategy_name}' has no on_start method, marked as trading.", level=DEBUG,
                               strategy=strategy)
            if start_success:
                self.write_log(f"Strategy '{strategy_name}' started successfully.", level=INFO, strategy=strategy)
            else:
                self.write_log(f"Strategy '{strategy_name}' failed to start (check logs for errors in on_start).",
                               level=WARNING, strategy=strategy)
        except Exception as e:
            strategy.trading = False
            self.write_log(f"Unexpected error during start process for '{strategy_name}': {e}", level=ERROR,
                           strategy=strategy)
        finally:
            self.put_strategy_update_event(strategy)

    @virtual
    def stop_strategy(self, strategy_name: str) -> None:
        """Stop trading for a strategy."""
        if strategy_name not in self.strategies:
            self.write_log(f"Stop failed: Strategy '{strategy_name}' not found.", level=ERROR);
            return
        strategy = self.strategies[strategy_name]
        if not strategy.trading:
            self.write_log(f"Stop ignored: Strategy '{strategy_name}' is already stopped.", level=DEBUG,
                           strategy=strategy);
            return
        self.write_log(f"Stopping strategy: {strategy_name}...", level=INFO, strategy=strategy)
        strategy.trading = False
        try:
            self._cancel_strategy_orders(strategy)
            if hasattr(strategy, 'on_stop') and callable(strategy.on_stop):
                self.write_log(f"Calling {strategy_name}.on_stop()...", level=DEBUG, strategy=strategy)
                self.call_strategy_func(strategy, strategy.on_stop)
            self.save_strategy_data(strategy_name)
            self.write_log(f"Strategy '{strategy_name}' stopped successfully.", level=INFO, strategy=strategy)
        except Exception as e:
            self.write_log(f"Error during stop process for '{strategy_name}': {e}\n{traceback.format_exc()}",
                           level=ERROR, strategy=strategy)
        finally:
            self.put_strategy_update_event(strategy)

    def _cancel_strategy_orders(self, strategy: StrategyTemplate) -> None:
        """[Internal] Cancel all active orders reported by a strategy."""
        strategy_name = strategy.strategy_name
        self.write_log(f"Cancelling active orders for strategy '{strategy_name}'...", level=DEBUG, strategy=strategy)
        if not (hasattr(strategy, 'get_active_order_ids') and callable(strategy.get_active_order_ids)):
            self.write_log(
                f"Cannot cancel orders: Strategy '{strategy_name}' does not implement get_active_order_ids().",
                level=WARNING, strategy=strategy);
            return
        try:
            active_order_ids: List[str] = strategy.get_active_order_ids()
            if not isinstance(active_order_ids, list):
                self.write_log(
                    f"Strategy '{strategy_name}' get_active_order_ids() did not return a list. Cannot cancel orders.",
                    level=WARNING, strategy=strategy);
                return
        except Exception:
            self.write_log(
                f"Error calling get_active_order_ids() for strategy '{strategy_name}':\n{traceback.format_exc()}",
                level=ERROR, strategy=strategy);
            return
        if not active_order_ids:
            self.write_log(f"No active orders reported by strategy '{strategy_name}' to cancel.", level=DEBUG,
                           strategy=strategy);
            return
        self.write_log(
            f"Strategy '{strategy_name}' reported {len(active_order_ids)} active order(s): {active_order_ids}. Attempting cancellation.",
            level=DEBUG, strategy=strategy)
        cancelled_count = 0
        for vt_orderid in list(active_order_ids):  # Iterate over copy
            if not isinstance(vt_orderid, str):
                self.write_log(f"Skipping invalid order ID from {strategy_name}: {vt_orderid}", level=WARNING,
                               strategy=strategy);
                continue
            order = self.main_engine.get_order(vt_orderid)
            if order and order.is_active():
                try:
                    self.cancel_order(order)  # Use engine's method which handles mode
                    cancelled_count += 1
                except Exception:
                    self.write_log(
                        f"Failed to send cancel request for order {vt_orderid} (Strategy: {strategy_name}):\n{traceback.format_exc()}",
                        level=ERROR, strategy=strategy)
        self.write_log(
            f"Sent cancel requests for {cancelled_count}/{len(active_order_ids)} active orders reported by '{strategy_name}'.",
            level=INFO, strategy=strategy)

    @virtual
    def init_all_strategies(self) -> None:
        """Initialize all strategy instances that are not already initialized."""
        self.write_log("Initializing all strategies...", level=INFO)
        strategy_names = list(self.strategies.keys())
        init_queued_count = 0
        for name in strategy_names:
            if name in self.strategies and not self.strategies[name].inited:
                self.init_strategy(name)
                init_queued_count += 1
        self.write_log(f"Queued initialization for {init_queued_count} strategies.", level=INFO)

    @virtual
    def start_all_strategies(self) -> None:
        """Start all strategy instances that are initialized but not trading."""
        self.write_log("Starting all initialized strategies...", level=INFO)
        strategy_names = list(self.strategies.keys())
        start_attempt_count = 0
        for name in strategy_names:
            if name in self.strategies:
                strategy = self.strategies[name]
                if strategy.inited and not strategy.trading:
                    self.start_strategy(name)
                    start_attempt_count += 1
        self.write_log(f"Attempted to start {start_attempt_count} initialized strategies.", level=INFO)

    @virtual
    def stop_all_strategies(self) -> None:
        """Stop all strategy instances that are currently trading."""
        self.write_log("Stopping all running strategies...", level=INFO)
        strategy_names = list(self.strategies.keys())
        stop_attempt_count = 0
        for name in strategy_names:
            if name in self.strategies and self.strategies[name].trading:
                self.stop_strategy(name)
                stop_attempt_count += 1
        self.write_log(f"Attempted to stop {stop_attempt_count} running strategies.", level=INFO)
        self.save_all_strategy_data()

    # --------------------------------
    # Event Processing Callbacks
    # --------------------------------
    def process_order_event(self, event: Event) -> None:
        """Process ORDER events: Forward to the relevant strategy instance."""
        order: OrderData = event.data
        if not isinstance(order, OrderData): return
        reference = getattr(order, 'reference', None)
        if not reference: return
        strategy = self.strategies.get(reference)
        if strategy and hasattr(strategy, 'on_order') and callable(strategy.on_order):
            self.call_strategy_func(strategy, strategy.on_order, order)

    def process_trade_event(self, event: Event) -> None:
        """Process TRADE events: Forward to the relevant strategy instance."""
        trade: TradeData = event.data
        if not isinstance(trade, TradeData): return
        reference = getattr(trade, 'reference', None)
        if not reference and self.portfolio_engine:
            reference = self.portfolio_engine.order_reference_map.get(trade.vt_orderid)
            if reference: trade.reference = reference
        if not reference: return
        strategy = self.strategies.get(reference)
        if strategy and hasattr(strategy, 'on_trade') and callable(strategy.on_trade):
            self.call_strategy_func(strategy, strategy.on_trade, trade)

    def process_factor_event(self, event: Event) -> None:
        """Process FACTOR events: Update cache and trigger `on_factor` for active strategies."""
        factor_memories: Dict[str, "FactorMemory"] = event.data
        if not isinstance(factor_memories, dict):
            self.write_log(f"Ignoring factor event: Data is not a dictionary (Type: {type(factor_memories)}).",
                           level=WARNING)
            return
        if not factor_memories:
            self.write_log("Ignoring factor event: Data dictionary is empty.", level=DEBUG)
            return

        self.write_log(f"Processing factor update with FactorMemory objects: {list(factor_memories.keys())}", level=DEBUG)
        self.latest_factor_memories = factor_memories # Cache the received FactorMemory objects
        self.factor_update_time = self.get_current_datetime()  # Use engine time

        active_strategies = [s for s in list(self.strategies.values()) if s.inited and s.trading]
        for strategy in active_strategies:
            if hasattr(strategy, 'on_factor') and callable(strategy.on_factor):
                # Pass the entire dictionary of FactorMemory objects to the strategy
                order_reqs: Optional[List[OrderRequest]] = self.call_strategy_func(
                    strategy, strategy.on_factor, factor_memories
                )
                if isinstance(order_reqs, list):
                    for req in order_reqs:
                        if isinstance(req, OrderRequest):
                            self.send_order(strategy_name=strategy.strategy_name, req=req)
                        else:
                            self.write_log(
                                f"Strategy '{strategy.strategy_name}' returned invalid item in on_factor list: {type(req)}",
                                level=WARNING, strategy=strategy)
                elif order_reqs is not None:
                    self.write_log(
                        f"Strategy '{strategy.strategy_name}' on_factor returned unexpected type: {type(order_reqs)}",
                        level=WARNING, strategy=strategy)

    def _process_timer_event(self, event: Event) -> None:
        """Process TIMER events to check for strategy model retraining schedules."""
        current_datetime = self.get_current_datetime()

        # Iterate over a copy of strategy values if strategies dict could be modified
        for strategy in list(self.strategies.values()):
            if not (strategy.inited and strategy.trading):
                continue

            if not (hasattr(strategy, 'check_retraining_schedule') and callable(strategy.check_retraining_schedule)):
                continue
            if not (hasattr(strategy, 'train_model') and callable(strategy.train_model)):
                continue

            try:
                if strategy.check_retraining_schedule(current_datetime):
                    self.write_log(f"Retraining condition met for strategy '{strategy.strategy_name}'. "
                                   f"Queueing model training.", level=INFO, strategy=strategy)
                    self.init_executor.submit(self._train_strategy_model_thread, strategy.strategy_name)
            except Exception as e:
                self.write_log(f"Error during check_retraining_schedule for '{strategy.strategy_name}': {e}",
                               level=ERROR, strategy=strategy)

    def _train_strategy_model_thread(self, strategy_name: str) -> None:
        """
        [Internal] Worker thread function for training a single strategy's model.
        Prepares data from FactorMemory and calls strategy.train_model.
        """
        strategy = self.strategies.get(strategy_name)
        if not strategy:
            self.write_log(f"Model training aborted: Strategy '{strategy_name}' not found.", level=WARNING)
            return
        if not (strategy.inited and strategy.trading):
            self.write_log(f"Model training aborted for '{strategy_name}': Strategy no longer inited or trading.",
                           level=INFO, strategy=strategy)
            return

        self.write_log(f"Starting model training process for strategy: {strategy_name}",
                       level=INFO, strategy=strategy)
        
        if not self.latest_factor_memories:
            self.write_log(f"Cannot train model for '{strategy_name}': No FactorMemory objects available in engine cache.",
                           level=ERROR, strategy=strategy)
            return

        required_factors = getattr(strategy, 'required_factors', [])
        if not required_factors:
            self.write_log(f"Cannot train model for '{strategy_name}': Strategy has no 'required_factors' defined.",
                           level=WARNING, strategy=strategy)
            return

        training_data_parts: Dict[str, pd.DataFrame] = {}
        all_factors_available = True
        for factor_name in required_factors:
            factor_memory = self.latest_factor_memories.get(factor_name)
            if not factor_memory:
                self.write_log(f"Cannot train model for '{strategy_name}': Required factor '{factor_name}' "
                               f"not found in latest FactorMemory cache.", level=ERROR, strategy=strategy)
                all_factors_available = False
                break
            
            try:
                # Fetch all historical data for this factor
                polars_df = factor_memory.get_data() 
                if polars_df is None or polars_df.is_empty():
                    self.write_log(f"Factor '{factor_name}' provided no historical data (get_data returned empty). "
                                   f"Skipping for training of '{strategy_name}'.", level=WARNING, strategy=strategy)
                    # Depending on strategy, might need to skip training or proceed with partial data
                    all_factors_available = False # Or handle as per strategy needs
                    break
                
                pandas_df = polars_df.to_pandas()
                
                # Basic validation of the structure from FactorMemory.get_data()
                # Expects at least 'vt_symbol', 'datetime', and a value column
                if not all(col in pandas_df.columns for col in ['vt_symbol', 'datetime']):
                    self.write_log(f"Factor '{factor_name}' DataFrame from get_data() missing 'vt_symbol' or 'datetime'. "
                                   f"Schema: {pandas_df.columns}. Skipping for training.", level=WARNING, strategy=strategy)
                    all_factors_available = False
                    break

                # Identify value column (similar to on_factor)
                value_col_found = False
                if 'value' in pandas_df.columns:
                    renamed_df = pandas_df.rename(columns={'value': factor_name})
                    value_col_found = True
                elif factor_name in pandas_df.columns: # If factor_name is already a column
                    renamed_df = pandas_df
                    value_col_found = True
                else:
                    # Try to infer if only one other column apart from vt_symbol, datetime
                    potential_value_cols = [c for c in pandas_df.columns if c not in ['vt_symbol', 'datetime']]
                    if len(potential_value_cols) == 1:
                        renamed_df = pandas_df.rename(columns={potential_value_cols[0]: factor_name})
                        value_col_found = True
                
                if not value_col_found:
                    self.write_log(f"Factor '{factor_name}' DataFrame from get_data() has no clear value column "
                                   f"(expected 'value', '{factor_name}', or single other). Schema: {pandas_df.columns}. "
                                   f"Skipping for training.", level=WARNING, strategy=strategy)
                    all_factors_available = False
                    break

                # Pivot or set index to align data by datetime and vt_symbol
                # Assuming 'datetime' is the primary index for time-series alignment
                # And 'vt_symbol' for cross-sectional alignment for each factor value
                # Example: set_index(['datetime', 'vt_symbol']) and select factor_name column
                processed_df = renamed_df.set_index(['datetime', 'vt_symbol'])[[factor_name]]
                training_data_parts[factor_name] = processed_df

            except Exception as e:
                self.write_log(f"Error processing historical data for factor '{factor_name}' for training '{strategy_name}': {e}\n"
                               f"{traceback.format_exc()}", level=ERROR, strategy=strategy)
                all_factors_available = False
                break
        
        if not all_factors_available or not training_data_parts:
            self.write_log(f"Model training for '{strategy_name}' aborted due to missing or incomplete factor data.",
                           level=ERROR, strategy=strategy)
            return

        try:
            # Combine all factor data into a single DataFrame aligned by ('datetime', 'vt_symbol')
            # Using outer join to keep all data points, then handle NaNs
            combined_df = pd.concat(training_data_parts.values(), axis=1, join='outer')
            
            # Handle NaNs after combining - strategy might prefer specific imputation
            # For now, log and let strategy's train_model handle it or fill with a placeholder
            if combined_df.isnull().values.any():
                self.write_log(f"Combined training DataFrame for '{strategy_name}' contains NaNs. "
                               f"Shape: {combined_df.shape}. Consider handling NaNs before training.", level=WARNING, strategy=strategy)
                # Example: combined_df = combined_df.fillna(method='ffill').fillna(0) # Forward fill then zero fill
                # This should ideally be part of the strategy's data prep within train_model
            
            # Reset index if train_model expects flat DataFrame, or pass as is if it handles multi-index
            # Assuming train_model can handle multi-index or will reset it.
            # combined_df = combined_df.reset_index() 

            self.write_log(f"Successfully prepared combined training data for '{strategy_name}'. Shape: {combined_df.shape}",
                           level=DEBUG, strategy=strategy)

        except Exception as e:
            self.write_log(f"Error combining/aligning historical factor data for training '{strategy_name}': {e}\n"
                           f"{traceback.format_exc()}", level=ERROR, strategy=strategy)
            return

        # Call the strategy's train_model method
        training_successful = False
        try:
            self.write_log(f"Calling {strategy_name}.train_model()...", level=INFO, strategy=strategy)
            # Assuming strategy.train_model will use the combined_df and update its internal self.model
            # and self.last_retrain_time
            self.call_strategy_func(strategy, strategy.train_model, combined_df)
            
            # Check if model attribute was updated (simple check)
            if hasattr(strategy, 'model') and strategy.model is not None:
                 # Check if last_retrain_time was updated by the strategy
                if hasattr(strategy, 'last_retrain_time') and isinstance(strategy.last_retrain_time, datetime):
                    if (self.get_current_datetime() - strategy.last_retrain_time).total_seconds() < 600: # Updated recently
                        training_successful = True
            
            if training_successful:
                self.write_log(f"Model training completed for strategy: {strategy_name}. "
                               f"Last retrained: {strategy.last_retrain_time}", level=INFO, strategy=strategy)
            else:
                self.write_log(f"Model training for strategy: {strategy_name} finished, but model/retrain_time "
                               f"not updated as expected. Review strategy's train_model method.", level=WARNING, strategy=strategy)

        except Exception as e: # call_strategy_func already logs, but good to have specific message here
            self.write_log(f"Exception during {strategy_name}.train_model(): {e}", level=ERROR, strategy=strategy)
            # call_strategy_func would have already logged the full traceback.
        
        # Update strategy state event if needed (e.g., if last_retrain_time changed)
        self.put_strategy_update_event(strategy)


    # --------------------------------
    # Order Submission and Cancellation (Via ExecutionAgent / Backtester)
    # --------------------------------
    @virtual
    def send_order(
            self,
            strategy_name: str,
            req: OrderRequest,
            lock: bool = False,
            net: bool = False
    ) -> List[str]:
        """
        Send an order request, handling live vs. backtesting modes.
        Sets the order reference to the strategy name.
        """
        strategy = self.strategies.get(strategy_name)
        req.reference = strategy_name

        log_msg = (f"Sending order: Ref={req.reference}, {req.vt_symbol} "
                   f"{req.direction} {req.type} {req.volume}@{req.price}")
        self.write_log(log_msg, level=INFO, strategy=strategy)

        if not all([req.vt_symbol, req.direction, req.type, req.volume is not None]):
            self.write_log(f"Order rejected: Missing required fields in OrderRequest: {req}", level=ERROR,
                           strategy=strategy)
            return []

        if self.get_engine_type() == EngineType.BACKTESTING:
            try:
                vt_orderid = self.main_engine.send_order(req, gateway_name="BACKTESTING")
                self.write_log(f"Order submitted to Backtester. VT OrderID: {vt_orderid}", level=INFO,
                               strategy=strategy)
                return [vt_orderid] if vt_orderid else []
            except AttributeError:
                self.write_log("Backtesting Error: MainEngine does not have 'send_order' method.", level=ERROR);
                return []
            except Exception:
                self.write_log(f"Exception during backtesting order submission:\n{traceback.format_exc()}", level=ERROR,
                               strategy=strategy);
                return []
        else:  # Live Trading
            try:
                vt_orderids: List[str] = self.execution_agent.send_order(req=req, lock=lock, net=net)
                if vt_orderids:
                    self.write_log(f"Order submitted via ExecutionAgent. VT OrderIDs: {vt_orderids}", level=INFO,
                                   strategy=strategy)
                    return vt_orderids
                else:
                    self.write_log("Order submission failed (ExecutionAgent returned empty list).", level=ERROR,
                                   strategy=strategy)
                    return []
            except Exception:
                self.write_log(f"Exception during order submission via ExecutionAgent:\n{traceback.format_exc()}",
                               level=ERROR, strategy=strategy)
                return []

    @virtual
    def cancel_order(self, req: Union[CancelRequest, OrderData]) -> None:
        """Cancel an active order, handling live vs. backtesting modes."""
        cancel_req: Optional[CancelRequest] = None
        vt_orderid_log = "N/A";
        strategy_ref_log = ""

        if isinstance(req, OrderData):
            vt_orderid_log = req.vt_orderid
            strategy_ref_log = f" (Ref: {req.reference})" if req.reference else ""
            if not req.is_active():
                self.write_log(f"Cancel ignored: Order {vt_orderid_log} is already inactive.", level=DEBUG);
                return
            try:
                cancel_req = req.create_cancel_request()
            except Exception:
                self.write_log(
                    f"Failed to create CancelRequest from OrderData (ID: {vt_orderid_log}):\n{traceback.format_exc()}",
                    level=ERROR);
                return
        elif isinstance(req, CancelRequest):
            cancel_req = req;
            vt_orderid_log = req.vt_orderid
            order_data = self.main_engine.get_order(vt_orderid_log)
            if order_data and order_data.reference: strategy_ref_log = f" (Ref: {order_data.reference})"
        else:
            self.write_log(f"Invalid type passed to cancel_order: {type(req)}.", level=ERROR);
            return

        if not cancel_req: return

        self.write_log(f"Attempting cancellation for order ID: {vt_orderid_log}{strategy_ref_log}", level=INFO)

        if self.get_engine_type() == EngineType.BACKTESTING:
            try:
                self.main_engine.cancel_order(cancel_req, gateway_name="BACKTESTING")
                self.write_log(f"Cancel request sent to Backtester for order {vt_orderid_log}.", level=INFO)
            except AttributeError:
                self.write_log("Backtesting Error: MainEngine does not have 'cancel_order' method.", level=ERROR)
            except Exception:
                self.write_log(
                    f"Exception during backtesting order cancellation (ID: {vt_orderid_log}):\n{traceback.format_exc()}",
                    level=ERROR)
        else:  # Live Trading
            try:
                self.execution_agent.cancel_order(cancel_req)
            except Exception:
                self.write_log(
                    f"Exception during order cancellation via ExecutionAgent (ID: {vt_orderid_log}):\n{traceback.format_exc()}",
                    level=ERROR)

    # --------------------------------
    # Utility Methods for Strategies
    # --------------------------------
    def get_contract(self, vt_symbol: str) -> Optional[ContractData]:
        """Get contract details from MainEngine."""
        return self.main_engine.get_contract(vt_symbol)

    def get_tick(self, vt_symbol: str) -> Optional[TickData]:
        """Get the latest tick data from MainEngine."""
        return self.main_engine.get_tick(vt_symbol)

    def get_bar(self, vt_symbol: str) -> Optional[BarData]:
        """Get the latest bar data from MainEngine (if available)."""
        return self.main_engine.get_bar(vt_symbol)

    def get_pricetick(self, strategy: StrategyTemplate, vt_symbol: str) -> Optional[float]:
        """Get the price tick (minimum price increment) for a contract."""
        contract = self.get_contract(vt_symbol)
        if contract:
            return contract.pricetick
        else:
            self.write_log(f"Failed to get pricetick for {vt_symbol}: Contract not found.", strategy=strategy,
                           level=WARNING)
            return None

    def get_size(self, strategy: StrategyTemplate, vt_symbol: str) -> Optional[float]:
        """Get the contract size (multiplier)."""
        contract = self.get_contract(vt_symbol)
        if contract:
            return contract.size
        else:
            self.write_log(f"Failed to get size for {vt_symbol}: Contract not found.", strategy=strategy, level=WARNING)
            return None

    def get_engine_type(self) -> EngineType:
        """Return the current engine type (LIVE or BACKTESTING)."""
        if hasattr(self.main_engine, "engine_type"):
            return self.main_engine.engine_type
        return self.engine_type

    def get_current_datetime(self) -> datetime:
        """Get current datetime (UTC in live, backtest time in backtesting)."""
        if self.get_engine_type() == EngineType.BACKTESTING:
            dt = getattr(self.main_engine, "datetime", None)
            if dt and isinstance(dt, datetime):
                return dt
            else:
                self.write_log("Backtesting time not available via main_engine.datetime. Falling back to system time.",
                               level=ERROR)
                return datetime.now(timezone.utc)
        else:
            return datetime.now(timezone.utc)

    # --- Portfolio Data Accessors ---
    def get_portfolio_position(self, strategy_name: str, vt_symbol: str) -> float:
        """Get current position size for a symbol tracked by the PortfolioEngine."""
        if not self.portfolio_engine:
            self.write_log("Cannot get portfolio position: PortfolioEngine is disabled.", level=WARNING);
            return 0.0
        contract_result = self.portfolio_engine.contract_results.get((strategy_name, vt_symbol))
        return contract_result.last_pos if contract_result else 0.0

    def get_portfolio_entry_price(self, strategy_name: str, vt_symbol: str) -> float:
        """Get average entry price for the current position tracked by PortfolioEngine."""
        if not self.portfolio_engine:
            self.write_log("Cannot get entry price: PortfolioEngine is disabled.", level=WARNING);
            return 0.0
        contract_result = self.portfolio_engine.contract_results.get((strategy_name, vt_symbol))
        return contract_result.avg_price if contract_result else 0.0

    def get_portfolio_pnl(self, strategy_name: str, vt_symbol: str) -> Tuple[float, float, float]:
        """Get (Trading PnL, Holding PnL, Total PnL) tracked by PortfolioEngine."""
        if not self.portfolio_engine:
            self.write_log("Cannot get PnL: PortfolioEngine is disabled.", level=WARNING);
            return 0.0, 0.0, 0.0
        contract_result = self.portfolio_engine.contract_results.get((strategy_name, vt_symbol))
        if contract_result:
            return (contract_result.trading_pnl, contract_result.holding_pnl, contract_result.total_pnl)
        else:
            return 0.0, 0.0, 0.0

    def get_portfolio_total_pnl(self, strategy_name: str) -> float:
        """Get the aggregated Total PnL for the entire strategy portfolio."""
        if not self.portfolio_engine:
            self.write_log("Cannot get total PnL: PortfolioEngine is disabled.", level=WARNING);
            return 0.0
        portfolio_result = self.portfolio_engine.portfolio_results.get(strategy_name)
        return portfolio_result.total_pnl if portfolio_result else 0.0

    # --- Strategy Information Accessors ---
    def get_all_strategy_class_names(self) -> List[str]:
        """Return a list of names of all loaded strategy classes."""
        return list(self.strategy_classes.keys())

    def get_strategy_class_parameters(self, class_name: str) -> Optional[dict]:
        """Get the default parameters defined in a strategy class."""
        strategy_class = self.strategy_classes.get(class_name)
        if not strategy_class:
            self.write_log(f"Cannot get class parameters: Strategy class '{class_name}' not found.", level=ERROR);
            return None
        params = {}
        param_names = getattr(strategy_class, "parameters", [])
        for name in param_names:
            params[name] = getattr(strategy_class, name, None)
        return params

    def get_strategy_parameters(self, strategy_name: str) -> Optional[dict]:
        """Get the current parameters of a running strategy instance."""
        strategy = self.strategies.get(strategy_name)
        if not strategy:
            self.write_log(f"Cannot get parameters: Strategy instance '{strategy_name}' not found.", level=ERROR);
            return None
        if hasattr(strategy, 'get_parameters') and callable(strategy.get_parameters):
            return strategy.get_parameters()
        else:
            self.write_log(f"Strategy '{strategy_name}' does not implement get_parameters().", level=WARNING,
                           strategy=strategy)
            return getattr(strategy, 'setting', None)

    # --------------------------------
    # Internal Helpers
    # --------------------------------
    def call_strategy_func(self, strategy: StrategyTemplate, func: Callable, params: Optional[Any] = None) -> Any:
        """Safely execute a method on a strategy instance, handling exceptions."""
        func_name = getattr(func, '__name__', 'unknown_function')
        try:
            if params is not None:
                return func(params)
            else:
                return func()
        except Exception:
            error_msg = (f"Strategy '{strategy.strategy_name}' encountered an exception in '{func_name}'. "
                         f"Stopping strategy to prevent further errors.\n{traceback.format_exc()}")
            self.write_log(error_msg, strategy=strategy, level=ERROR)
            if strategy.trading:
                strategy.trading = False
                self.put_strategy_update_event(strategy)
            return None

    def put_strategy_update_event(self, strategy: StrategyTemplate, removed: bool = False) -> None:
        """Publish an event notifying listeners of a strategy state change or removal."""
        try:
            data: dict
            if hasattr(strategy, 'get_data') and callable(strategy.get_data):
                data = strategy.get_data()
                if not isinstance(data, dict):
                    self.write_log(
                        f"Strategy '{strategy.strategy_name}'.get_data() did not return dict. Sending minimal update.",
                        level=WARNING, strategy=strategy)
                    data = {}
            else:
                data = {}
            data.update({
                "strategy_name": strategy.strategy_name,
                "class_name": strategy.__class__.__name__,
                "inited": getattr(strategy, 'inited', False),
                "trading": getattr(strategy, 'trading', False),
                "removed": removed
            })
            event = Event(type=EVENT_STRATEGY_UPDATE, data=data)
            self.event_engine.put(event)
        except Exception as e:
            self.write_log(f"Error preparing or putting strategy update event for '{strategy.strategy_name}': {e}",
                           level=ERROR, strategy=strategy)

    @virtual
    def write_log(self, msg: str, strategy: Optional[StrategyTemplate] = None, level: int = INFO) -> None:
        """Write a log message, prefixing with source and pushing to vnpy event log."""
        prefix = f"[{strategy.strategy_name}] " if strategy else ""
        log_entry = LogData(msg=f"{prefix}{msg}", gateway_name=self.engine_name, level=level)
        event = Event(type=EVENT_STRATEGY_LOG, data=log_entry)
        self.event_engine.put(event)

    def send_email(self, subject: str, msg: str, strategy: Optional[StrategyTemplate] = None) -> None:
        """Send an email notification through the MainEngine."""
        full_subject = f"[{strategy.strategy_name if strategy else self.engine_name}] {subject}"
        try:
            self.main_engine.send_email(full_subject, msg)
            self.write_log(f"Sent email notification: Subject: {full_subject}", level=INFO, strategy=strategy)
        except Exception:
            self.write_log(f"Failed to send email: Subject: {full_subject}\n{traceback.format_exc()}", level=ERROR,
                           strategy=strategy)
