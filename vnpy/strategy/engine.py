# -*- coding: utf-8 -*-
"""
Defines the BaseStrategyEngine, the core component for managing and executing
trading strategies within the vn.py framework. It integrates portfolio
management capabilities via an optional PortfolioEngine.

Core Responsibilities:
- Loading strategy code modules and configuration settings.
- Managing the lifecycle of strategy instances (initialization, start, stop).
- Subscribing to necessary market data for strategies.
- Processing market events (e.g., factor updates) and triggering strategy logic.
- Handling order requests generated by strategies via a dedicated ExecutionAgent.
- Routing order and trade update events back to the relevant strategy instances.
- Providing utility functions for strategies to access market data, contract details,
  and portfolio state (if PortfolioEngine is active).
- Persisting strategy settings and optional runtime state.
"""

import importlib
import traceback
import os
import sys
import glob
from typing import Type, Callable, Dict, List, Optional, Any, Tuple, Set, Union
from datetime import datetime, timezone, date
from concurrent.futures import ThreadPoolExecutor
from logging import INFO, ERROR, DEBUG, WARNING # Standard logging levels
from pathlib import Path
from types import ModuleType

# --- VnTrader Core Imports ---
from vnpy.event import Event, EventEngine
from vnpy.strategy.base import EVENT_PORTFOLIO_STRATEGY
from vnpy.trader.engine import BaseEngine, MainEngine
from vnpy.trader.object import (
    OrderRequest, SubscribeRequest, CancelRequest,
    LogData, TickData, OrderData, TradeData, BarData, ContractData
)
from vnpy.trader.event import (
    EVENT_ORDER, EVENT_TRADE, EVENT_CONTRACT, EVENT_TIMER, EVENT_LOG,
    EVENT_FACTOR
)
from vnpy.trader.constant import EngineType
from vnpy.trader.utility import load_json, save_json, get_file_path, virtual
from vnpy.trader.database import BaseDatabase, get_database
from vnpy.trader.datafeed import BaseDatafeed, get_datafeed

# --- Strategy & Portfolio Specific Imports ---
# Attempt to import dependencies, provide fallbacks or clear errors
from vnpy.app.portfolio_manager.engine import PortfolioEngine
PORTFOLIO_APP_NAME = PortfolioEngine.APP_NAME


from vnpy.strategy.execution_agent import ExecutionAgent



# Import the base StrategyTemplate
from vnpy.strategy.template import StrategyTemplate

# --- Constants ---
STRATEGY_ENGINE_APP_NAME: str = "StrategyEngine"   # Default unique name for this engine
DEFAULT_STRATEGIES_DIR: str = "strategies"         # Default subdirectory for strategy code
DEFAULT_EXECUTION_GATEWAY: str = "BINANCE"         # Default gateway for order execution

# Filename Templates
SETTING_FILENAME_TPL: str = "{}_setting.json"       # Template for engine settings filename
STRATEGY_DATA_FILENAME_TPL: str = "strategy_data_{}.json" # Template for strategy runtime data

# Event Types
EVENT_STRATEGY_LOG = EVENT_LOG                     # Use standard log event type
EVENT_STRATEGY_UPDATE = EVENT_PORTFOLIO_STRATEGY   # Use standard strategy update event type


class BaseStrategyEngine(BaseEngine):
    """
    Core engine for loading, managing the lifecycle, and executing trading
    strategies derived from `StrategyTemplate`. Integrates with an optional
    `PortfolioEngine` for PnL and position tracking.
    """

    # Engine type can be overridden by MainEngine in backtesting mode
    engine_type: EngineType = EngineType.LIVE

    def __init__(
        self,
        main_engine: MainEngine,
        event_engine: EventEngine,
        engine_name: str = STRATEGY_ENGINE_APP_NAME
    ) -> None:
        """
        Initialize the BaseStrategyEngine.

        Args:
            main_engine: The main trading engine instance.
            event_engine: The central event engine instance.
            engine_name: A unique name for this engine instance.
        """
        super().__init__(main_engine, event_engine, engine_name=engine_name)

        # --- Load Configuration from MainEngine Settings ---
        # Allow overriding defaults via vnpy's global settings if available
        engine_settings = main_engine.get_settings(f"{engine_name}.") # Prefix for engine-specific settings
        strategies_dir = engine_settings.get("strategies_dir", DEFAULT_STRATEGIES_DIR)
        self.execution_gateway_name = engine_settings.get("execution_gateway", DEFAULT_EXECUTION_GATEWAY)

        self.strategies_path: Path = Path.cwd().joinpath(strategies_dir)
        self.setting_filename: str = SETTING_FILENAME_TPL.format(self.engine_name)

        self.write_log(f"Engine Name: {self.engine_name}", level=DEBUG)
        self.write_log(f"Strategies Directory: {self.strategies_path}", level=INFO)
        self.write_log(f"Execution Gateway: {self.execution_gateway_name}", level=INFO)
        self.write_log(f"Settings File: {self.setting_filename}", level=DEBUG)

        # --- Core Strategy State ---
        self.strategy_classes: Dict[str, Type[StrategyTemplate]] = {} # {ClassName: Class}
        self.strategies: Dict[str, StrategyTemplate] = {}           # {StrategyName: Instance}
        self.strategy_settings: Dict[str, dict] = {}                # {StrategyName: SettingDict} Loaded from file

        # --- Supporting Components ---
        self.database: BaseDatabase = get_database()
        self.datafeed: BaseDatafeed = get_datafeed()
        self.execution_agent: ExecutionAgent = self._init_execution_agent()
        self.portfolio_engine: Optional[PortfolioEngine] = self._init_portfolio_engine()

        # --- Asynchronous Operations ---
        self.init_executor: ThreadPoolExecutor = ThreadPoolExecutor(
            max_workers=1, thread_name_prefix=f"{self.engine_name}_Init"
        )

        # --- Factor Handling ---
        self.latest_factors: Dict[str, Any] = {}
        self.factor_update_time: Optional[datetime] = None

        self.write_log("Engine initialization started.", level=DEBUG)

    def _init_execution_agent(self) -> ExecutionAgent:
        """Initialize the ExecutionAgent."""
        self.write_log(f"Initializing ExecutionAgent for gateway: {self.execution_gateway_name}", level=INFO)
        try:
            # Ensure ExecutionAgent class is valid before instantiation
            if not callable(ExecutionAgent) or ExecutionAgent.__name__ == 'object': # Check if it's the dummy
                raise ImportError("ExecutionAgent class is not valid or not imported.")
            agent = ExecutionAgent(
                main_engine=self.main_engine,
                gateway_name=self.execution_gateway_name
            )
            self.write_log("ExecutionAgent initialized successfully.", level=INFO)
            return agent
        except Exception as e:
            self.write_log(f"FATAL: Failed to initialize ExecutionAgent: {e}\n{traceback.format_exc()}", level=ERROR)
            print(f"FATAL ERROR in {self.engine_name}: ExecutionAgent failed. Order functionality disabled.")
            # Return a non-functional dummy to prevent crashes on attribute access
            class DummyExecutionAgent:
                def send_order(self, req: OrderRequest, lock: bool, net: bool) -> List[str]: self.log_error(req); return []
                def cancel_order(self, req: Union[CancelRequest, OrderData]) -> None: self.log_error(req)
                def log_error(self, req): print(f"ERROR: ExecutionAgent not initialized. Cannot process request: {req}")
            return DummyExecutionAgent()

    def _init_portfolio_engine(self) -> Optional[PortfolioEngine]:
        """Initialize the PortfolioEngine if available."""
        if PortfolioEngine: # Check if class was imported successfully
            self.write_log(f"Initializing PortfolioEngine ('{PORTFOLIO_APP_NAME}')...", level=INFO)
            try:
                portfolio_engine = PortfolioEngine(self.main_engine, self.event_engine)
                self.write_log(f"PortfolioEngine ('{PORTFOLIO_APP_NAME}') initialized successfully.", level=INFO)
                return portfolio_engine
            except Exception as e:
                self.write_log(f"Failed to initialize PortfolioEngine: {e}\n{traceback.format_exc()}", level=ERROR)
                return None
        else:
            self.write_log("PortfolioEngine class not available. Portfolio management disabled.", level=WARNING)
            return None

    # --------------------------------
    # Engine Lifecycle
    # --------------------------------

    def init_engine(self) -> None:
        """Initialize the engine: Load components, strategies, settings, data, and register events."""
        self.write_log("Initializing Strategy Engine components...")
        try:
            self.init_datafeed()
            self.load_all_strategy_classes()
            self.load_all_strategy_settings()
            self.create_strategies_from_settings()
            self.load_all_strategy_data()
            self.register_event()
            self.write_log(f"{self.engine_name} initialization complete. "
                           f"{len(self.strategies)} strategies loaded. "
                           f"Portfolio Management: {'ENABLED' if self.portfolio_engine else 'DISABLED'}", level=INFO)
        except Exception as e:
            self.write_log(f"CRITICAL ERROR during engine initialization: {e}\n{traceback.format_exc()}", level=ERROR)
            # Depending on severity, might want to stop the engine or raise exception

    def init_datafeed(self) -> None:
        """Initialize the data feed connection."""
        self.write_log("Initializing datafeed...", level=INFO)
        try:
            logger_callback = lambda msg: self.write_log(f"[DataFeed] {msg}", level=DEBUG)
            result: bool = self.datafeed.init(logger_callback)
            if result:
                self.write_log("Datafeed initialized successfully.", level=INFO)
            else:
                 self.write_log("Datafeed initialization failed (returned False). Check datafeed logs.", level=WARNING)
        except Exception as e:
             self.write_log(f"Exception during datafeed initialization: {e}", level=ERROR)

    def register_event(self) -> None:
        """Register event listeners required by the StrategyEngine."""
        self.write_log("Registering engine event listeners...", level=DEBUG)
        try:
            self.event_engine.register(EVENT_ORDER, self.process_order_event)
            self.event_engine.register(EVENT_TRADE, self.process_trade_event)
            self.event_engine.register(EVENT_FACTOR, self.process_factor_event)
            self.write_log("Engine event listeners registered.", level=DEBUG)
        except Exception as e:
            self.write_log(f"Error registering engine events: {e}", level=ERROR)

    def close(self) -> None:
        """Cleanly shut down the engine and its components."""
        self.write_log(f"Shutting down {self.engine_name}...")
        # 1. Stop strategies (cancels orders, calls on_stop, saves data)
        self.stop_all_strategies()
        # 2. Close Portfolio Engine (saves its state)
        if self.portfolio_engine:
            try:
                self.portfolio_engine.close()
                self.write_log(f"PortfolioEngine ('{PORTFOLIO_APP_NAME}') closed.", level=INFO)
            except Exception as e:
                self.write_log(f"Error closing PortfolioEngine: {e}\n{traceback.format_exc()}", level=ERROR)
        # 3. Unregister events
        self.unregister_event()
        # 4. Shut down thread pool
        self.write_log("Shutting down init executor...", level=DEBUG)
        self.init_executor.shutdown(wait=True)
        self.write_log("Init executor shut down.", level=DEBUG)
        self.write_log(f"{self.engine_name} shut down complete.", level=INFO)

    def unregister_event(self) -> None:
        """Unregister event listeners used by the StrategyEngine."""
        self.write_log("Unregistering engine event listeners...", level=DEBUG)
        try:
            self.event_engine.unregister(EVENT_ORDER, self.process_order_event)
            self.event_engine.unregister(EVENT_TRADE, self.process_trade_event)
            self.event_engine.unregister(EVENT_FACTOR, self.process_factor_event)
            self.write_log("Engine event listeners unregistered.", level=DEBUG)
        except Exception as e:
            self.write_log(f"Error unregistering engine events: {e}", level=ERROR)

    # --------------------------------
    # Strategy Loading and Settings
    # --------------------------------

    def load_all_strategy_classes(self) -> None:
        """Scan the strategies directory and load all found strategy classes."""
        self.write_log(f"Loading strategy classes from directory: {self.strategies_path}", level=INFO)
        if not self.strategies_path.is_dir():
            self.write_log(f"Strategies directory not found or is not a directory: {self.strategies_path}", level=ERROR)
            return

        initial_class_count = len(self.strategy_classes)
        # Determine module prefix based on path relative to potential package structure
        module_prefix = self.strategies_path.name

        for suffix in ["py", "pyd", "so"]: # Supported file types
            pathname = str(self.strategies_path.joinpath(f"*.{suffix}"))
            for filepath in glob.glob(pathname):
                module_path = Path(filepath)
                stem = module_path.stem
                if stem.startswith("_"): continue # Skip __init__, hidden files

                # Assume module name is relative to the strategies directory parent
                strategy_module_name = f"{module_prefix}.{stem}"
                try:
                    self._load_strategy_class_from_module(strategy_module_name)
                except ImportError:
                     # Fallback: Try importing just by stem name if relative import fails
                     self.write_log(f"Relative import failed for {strategy_module_name}, trying direct import of '{stem}'...", level=DEBUG)
                     try:
                          self._load_strategy_class_from_module(stem)
                     except ImportError as e:
                          self.write_log(f"Direct import also failed for '{stem}': {e}", level=ERROR)

        loaded_count = len(self.strategy_classes) - initial_class_count
        self.write_log(f"Finished loading strategy classes. Found {loaded_count} new classes. Total: {len(self.strategy_classes)}", level=INFO)

    def _load_strategy_class_from_module(self, module_name: str) -> int:
        """Load strategy classes from a specific module file, handling reload."""
        count = 0
        try:
            module_to_load: ModuleType
            if module_name in sys.modules:
                 module_to_load = importlib.reload(sys.modules[module_name])
                 self.write_log(f"Reloaded strategy module: {module_name}", level=DEBUG)
            else:
                 module_to_load = importlib.import_module(module_name)
                 self.write_log(f"Imported strategy module: {module_name}", level=DEBUG)

            for name in dir(module_to_load):
                value = getattr(module_to_load, name)
                if (isinstance(value, type) and issubclass(value, StrategyTemplate) and value is not StrategyTemplate):
                    class_name = value.__name__
                    if class_name in self.strategy_classes and self.strategy_classes[class_name] is not value:
                        self.write_log(f"Warning: Strategy class '{class_name}' from '{module_name}' conflicts with existing class. Skipping.", level=WARNING)
                        continue
                    if class_name not in self.strategy_classes:
                        self.strategy_classes[class_name] = value
                        count += 1
                        self.write_log(f"Loaded strategy class: '{class_name}' from '{module_name}'", level=DEBUG)
            return count
        except ModuleNotFoundError:
            # This exception is caught by the caller for fallback attempt
            self.write_log(f"Module '{module_name}' not found.", level=DEBUG) # Log failure at debug level here
            raise # Re-raise for caller to handle fallback
        except Exception:
            self.write_log(f"Failed to load strategy class from module '{module_name}':\n{traceback.format_exc()}", level=ERROR)
            return 0 # Don't re-raise other exceptions

    def load_all_strategy_settings(self) -> None:
        """Load strategy settings from the JSON configuration file."""
        self.write_log(f"Loading strategy settings from: {self.setting_filename}", level=INFO)
        filepath = get_file_path(self.setting_filename)
        loaded_settings = load_json(filepath) # Handles file not found/errors -> {}

        if not isinstance(loaded_settings, dict):
            self.write_log(f"Invalid settings file format in '{filepath}': Expected a dictionary, got {type(loaded_settings)}. Ignoring.", level=ERROR)
            self.strategy_settings = {}
        else:
            self.strategy_settings = loaded_settings
            self.write_log(f"Loaded settings for {len(self.strategy_settings)} strategies.", level=INFO)

    def create_strategies_from_settings(self) -> None:
        """Instantiate strategy objects based on the loaded settings."""
        self.write_log("Creating strategy instances from settings...", level=INFO)
        created_count = 0
        invalid_settings_names = []

        for strategy_name, setting in self.strategy_settings.items():
            if not self._validate_setting_entry(strategy_name, setting):
                invalid_settings_names.append(strategy_name)
                continue
            # Extract validated settings
            class_name = setting["class_name"]
            vt_symbols = setting["vt_symbols"]
            strategy_params = setting["setting"] # Parameters for the strategy class init

            if self.add_strategy(class_name, strategy_name, vt_symbols, strategy_params):
                created_count += 1
            else:
                invalid_settings_names.append(strategy_name) # Add failed

        # Clean up invalid settings from the runtime dictionary
        if invalid_settings_names:
            for name in invalid_settings_names:
                self.strategy_settings.pop(name, None)
            self.write_log(f"Removed {len(invalid_settings_names)} invalid or failed strategy settings from runtime config.", level=WARNING)
            # Optionally save the cleaned settings file
            # self.save_all_strategy_settings()

        self.write_log(f"Finished creating strategy instances. Successful: {created_count}", level=INFO)

    def _validate_setting_entry(self, strategy_name: str, setting: Any) -> bool:
        """Perform basic validation on a single strategy setting entry."""
        if not isinstance(setting, dict):
            self.write_log(f"Invalid setting for '{strategy_name}': Entry must be a dictionary.", level=WARNING)
            return False
        required_keys = {"class_name", "vt_symbols", "setting"}
        if not required_keys.issubset(setting.keys()):
            self.write_log(f"Invalid setting for '{strategy_name}': Missing required keys: {required_keys - set(setting.keys())}.", level=WARNING)
            return False
        class_name = setting["class_name"]
        if not isinstance(class_name, str) or not class_name:
            self.write_log(f"Invalid setting for '{strategy_name}': 'class_name' must be a non-empty string.", level=WARNING)
            return False
        if not isinstance(setting["vt_symbols"], list):
            self.write_log(f"Invalid setting for '{strategy_name}': 'vt_symbols' must be a list.", level=WARNING)
            return False
        if not isinstance(setting["setting"], dict):
            self.write_log(f"Invalid setting for '{strategy_name}': 'setting' (parameters) must be a dictionary.", level=WARNING)
            return False
        if class_name not in self.strategy_classes:
             self.write_log(f"Invalid setting for '{strategy_name}': Strategy class '{class_name}' is not loaded.", level=WARNING)
             return False
        return True

    def save_all_strategy_settings(self) -> None:
        """Save the current configuration of all active strategies to the settings file."""
        self.write_log(f"Saving strategy settings to: {self.setting_filename}", level=DEBUG)
        settings_to_save: Dict[str, dict] = {}
        for strategy_name, strategy in self.strategies.items():
            try:
                settings_to_save[strategy_name] = self._get_strategy_setting_dict(strategy)
            except Exception as e:
                 self.write_log(f"Error preparing settings for strategy '{strategy_name}' for saving: {e}", level=ERROR, strategy=strategy)

        filepath = get_file_path(self.setting_filename)
        if save_json(filepath, settings_to_save):
            self.write_log(f"Saved settings for {len(settings_to_save)} strategies to {filepath}", level=INFO)
        else:
            self.write_log(f"Failed to save strategy settings to {filepath} (save_json returned False)", level=ERROR)

    def _get_strategy_setting_dict(self, strategy: StrategyTemplate) -> dict:
        """Create the dictionary representation of a strategy's settings for saving."""
        if not hasattr(strategy, 'get_parameters') or not callable(strategy.get_parameters):
             raise AttributeError(f"Strategy '{strategy.strategy_name}' missing 'get_parameters' method.")
        # Use get_parameters which should handle serialization of configs etc.
        strategy_params = strategy.get_parameters()
        # Ensure vt_symbols and class_name are included at the top level
        strategy_params['vt_symbols'] = strategy.vt_symbols # Use current symbols
        strategy_params['class_name'] = strategy.__class__.__name__
        # Re-structure to match the expected load format {class_name, vt_symbols, setting:{...}}
        setting_dict = {
            "class_name": strategy_params.pop('class_name'),
            "vt_symbols": strategy_params.pop('vt_symbols'),
            "setting": strategy_params # Remaining items are the strategy-specific params
        }
        return setting_dict

    # --- (Keep update_strategy_setting_cache and remove_strategy_setting_cache as before) ---
    def update_strategy_setting_cache(self, strategy_name: str) -> None:
        """Update the internal settings cache (self.strategy_settings) for a single strategy."""
        # ... (implementation remains the same as v3) ...

    def remove_strategy_setting_cache(self, strategy_name: str) -> None:
        """Remove a strategy's setting from the internal cache. Does NOT save to file."""
        # ... (implementation remains the same as v3) ...

    # --------------------------------
    # Strategy Runtime Data Management
    # --------------------------------
    # --- (load_all_strategy_data, _load_single_strategy_data, save_strategy_data, save_all_strategy_data remain the same as v3) ---
    @virtual
    def load_all_strategy_data(self) -> None:
        """Load runtime data for all strategy instances that implement `load_data`."""
        # ... (implementation remains the same as v3) ...

    def _load_single_strategy_data(self, strategy: StrategyTemplate) -> bool:
        """Load runtime data for a single strategy instance if supported."""
        # ... (implementation remains the same as v3, using STRATEGY_DATA_FILENAME_TPL) ...

    @virtual
    def save_strategy_data(self, strategy_name: str) -> bool:
        """Save runtime data for a specific strategy instance if supported."""
        # ... (implementation remains the same as v3, using STRATEGY_DATA_FILENAME_TPL) ...

    def save_all_strategy_data(self) -> None:
        """Save runtime data for all active strategies that support it."""
        # ... (implementation remains the same as v3) ...


    # --------------------------------
    # Strategy Instance Management (Add, Edit, Remove)
    # --------------------------------
    # --- (add_strategy, edit_strategy, remove_strategy remain largely the same as v3, ensure consistency) ---
    def add_strategy(self, class_name: str, strategy_name: str, vt_symbols: List[str], setting: dict) -> bool:
        """Create, validate, and add a new strategy instance."""
        # ... (implementation remains the same as v3) ...

    def edit_strategy(self, strategy_name: str, setting: dict) -> bool:
        """Update parameters of an existing, stopped strategy instance. Saves settings."""
        # ... (implementation remains the same as v3) ...

    def remove_strategy(self, strategy_name: str, remove_data_file: bool = False) -> bool:
        """Remove a stopped strategy instance. Saves settings. Optionally removes data."""
        # ... (implementation remains the same as v3) ...


    # --------------------------------
    # Strategy Lifecycle Control (Init, Start, Stop)
    # --------------------------------
    # --- (init_strategy, _init_strategy_thread, _subscribe_strategy_data, _unsubscribe_strategy_data, start_strategy, stop_strategy, _cancel_strategy_orders, init_all_strategies, start_all_strategies, stop_all_strategies remain largely the same as v3) ---
    def init_strategy(self, strategy_name: str) -> None:
        """Asynchronously initialize a strategy instance."""
        # ... (implementation remains the same as v3) ...

    def _init_strategy_thread(self, strategy_name: str) -> None:
        """[Internal] Worker thread function for initializing a single strategy."""
        # ... (implementation remains the same as v3) ...

    def _subscribe_strategy_data(self, strategy: StrategyTemplate) -> bool:
        """[Internal] Subscribe to market data required by the strategy."""
        # ... (implementation remains the same as v3) ...

    def _unsubscribe_strategy_data(self, strategy: StrategyTemplate) -> None:
        """[Internal] Placeholder for unsubscribing market data for a strategy."""
        # ... (implementation remains the same as v3) ...

    @virtual
    def start_strategy(self, strategy_name: str) -> None:
        """Start trading for an initialized strategy."""
        # ... (implementation remains the same as v3) ...

    @virtual
    def stop_strategy(self, strategy_name: str) -> None:
        """Stop trading for a strategy."""
        # ... (implementation remains the same as v3) ...

    def _cancel_strategy_orders(self, strategy: StrategyTemplate) -> None:
        """[Internal] Cancel all active orders reported by a strategy."""
        # ... (implementation remains the same as v3) ...

    @virtual
    def init_all_strategies(self) -> None:
        """Initialize all strategy instances that are not already initialized."""
        # ... (implementation remains the same as v3) ...

    @virtual
    def start_all_strategies(self) -> None:
        """Start all strategy instances that are initialized but not trading."""
        # ... (implementation remains the same as v3) ...

    @virtual
    def stop_all_strategies(self) -> None:
        """Stop all strategy instances that are currently trading."""
        # ... (implementation remains the same as v3) ...


    # --------------------------------
    # Event Processing Callbacks
    # --------------------------------
    # --- (process_order_event, process_trade_event, process_factor_event remain largely the same as v3, ensure consistency) ---
    def process_order_event(self, event: Event) -> None:
        """Process ORDER events: Forward to the relevant strategy instance."""
        # ... (implementation remains the same as v3) ...

    def process_trade_event(self, event: Event) -> None:
        """Process TRADE events: Forward to the relevant strategy instance."""
        # ... (implementation remains the same as v3) ...

    def process_factor_event(self, event: Event) -> None:
        """Process FACTOR events: Update cache and trigger `on_factor` for active strategies."""
        # ... (implementation remains the same as v3) ...


    # --------------------------------
    # Order Submission and Cancellation (Via ExecutionAgent / Backtester)
    # --------------------------------
    @virtual
    def send_order(
            self,
            strategy_name: str,
            req: OrderRequest,
            lock: bool = False,
            net: bool = False
    ) -> List[str]:
        """
        Send an order request, handling live vs. backtesting modes.
        Sets the order reference to the strategy name.
        """
        strategy = self.strategies.get(strategy_name) # For logging context
        req.reference = strategy_name # Ensure reference is set

        log_msg = (f"Sending order: Ref={req.reference}, {req.vt_symbol} "
                   f"{req.direction} {req.type} {req.volume}@{req.price}")
        self.write_log(log_msg, level=INFO, strategy=strategy)

        if not all([req.vt_symbol, req.direction, req.type, req.volume is not None]): # Check volume is not None
             self.write_log(f"Order rejected: Missing required fields in OrderRequest: {req}", level=ERROR, strategy=strategy)
             return []

        # --- Mode-Specific Handling ---
        if self.get_engine_type() == EngineType.BACKTESTING:
            try:
                # Delegate to main_engine's backtesting send_order
                # Assumes main_engine has send_order for backtesting
                vt_orderid = self.main_engine.send_order(req, gateway_name="BACKTESTING")
                self.write_log(f"Order submitted to Backtester. VT OrderID: {vt_orderid}", level=INFO, strategy=strategy)
                return [vt_orderid] if vt_orderid else []
            except AttributeError:
                 self.write_log("Backtesting Error: MainEngine does not have 'send_order' method for backtesting.", level=ERROR)
                 return []
            except Exception:
                 self.write_log(f"Exception during backtesting order submission:\n{traceback.format_exc()}", level=ERROR, strategy=strategy)
                 return []
        else: # Live Trading
            try:
                vt_orderids: List[str] = self.execution_agent.send_order(req=req, lock=lock, net=net)
                if vt_orderids:
                    self.write_log(f"Order submitted via ExecutionAgent. VT OrderIDs: {vt_orderids}", level=INFO, strategy=strategy)
                    return vt_orderids
                else:
                    self.write_log("Order submission failed (ExecutionAgent returned empty list).", level=ERROR, strategy=strategy)
                    return []
            except Exception:
                self.write_log(f"Exception during order submission via ExecutionAgent:\n{traceback.format_exc()}", level=ERROR, strategy=strategy)
                return []


    @virtual
    def cancel_order(self, req: Union[CancelRequest, OrderData]) -> None:
        """Cancel an active order, handling live vs. backtesting modes."""
        cancel_req: Optional[CancelRequest] = None
        vt_orderid_log = "N/A"; strategy_ref_log = ""

        if isinstance(req, OrderData):
            vt_orderid_log = req.vt_orderid
            strategy_ref_log = f" (Ref: {req.reference})" if req.reference else ""
            if not req.is_active():
                 self.write_log(f"Cancel ignored: Order {vt_orderid_log} is already inactive.", level=DEBUG)
                 return
            try: cancel_req = req.create_cancel_request()
            except Exception: self.write_log(f"Failed to create CancelRequest from OrderData (ID: {vt_orderid_log}):\n{traceback.format_exc()}", level=ERROR); return
        elif isinstance(req, CancelRequest):
            cancel_req = req; vt_orderid_log = req.vt_orderid
            order_data = self.main_engine.get_order(vt_orderid_log)
            if order_data and order_data.reference: strategy_ref_log = f" (Ref: {order_data.reference})"
        else:
            self.write_log(f"Invalid type passed to cancel_order: {type(req)}.", level=ERROR); return

        if not cancel_req: return

        self.write_log(f"Attempting cancellation for order ID: {vt_orderid_log}{strategy_ref_log}", level=INFO)

        # --- Mode-Specific Handling ---
        if self.get_engine_type() == EngineType.BACKTESTING:
            try:
                # Delegate to main_engine's backtesting cancel_order
                self.main_engine.cancel_order(cancel_req, gateway_name="BACKTESTING")
                self.write_log(f"Cancel request sent to Backtester for order {vt_orderid_log}.", level=INFO)
            except AttributeError:
                 self.write_log("Backtesting Error: MainEngine does not have 'cancel_order' method for backtesting.", level=ERROR)
            except Exception:
                 self.write_log(f"Exception during backtesting order cancellation (ID: {vt_orderid_log}):\n{traceback.format_exc()}", level=ERROR)
        else: # Live Trading
            try:
                self.execution_agent.cancel_order(cancel_req)
                # Confirmation comes via ORDER event.
            except Exception:
                self.write_log(f"Exception during order cancellation via ExecutionAgent (ID: {vt_orderid_log}):\n{traceback.format_exc()}", level=ERROR)


    # --------------------------------
    # Utility Methods for Strategies
    # --------------------------------
    # --- (get_contract, get_tick, get_bar, get_pricetick, get_size, get_engine_type remain same as v3) ---
    def get_contract(self, vt_symbol: str) -> Optional[ContractData]:
        """Get contract details from MainEngine."""
        # ... (implementation remains the same as v3) ...
    def get_tick(self, vt_symbol: str) -> Optional[TickData]:
        """Get the latest tick data from MainEngine."""
        # ... (implementation remains the same as v3) ...
    def get_bar(self, vt_symbol: str) -> Optional[BarData]:
        """Get the latest bar data from MainEngine (if available)."""
        # ... (implementation remains the same as v3) ...
    def get_pricetick(self, strategy: StrategyTemplate, vt_symbol: str) -> Optional[float]:
        """Get the price tick (minimum price increment) for a contract."""
        # ... (implementation remains the same as v3) ...
    def get_size(self, strategy: StrategyTemplate, vt_symbol: str) -> Optional[float]:
        """Get the contract size (multiplier)."""
        # ... (implementation remains the same as v3) ...
    def get_engine_type(self) -> EngineType:
        """Return the current engine type (LIVE or BACKTESTING)."""
        # Check if engine_type was overridden by MainEngine (common in backtesting setups)
        if hasattr(self.main_engine, "engine_type"):
             return self.main_engine.engine_type
        return self.engine_type # Return own default if not overridden

    def get_current_datetime(self) -> datetime:
        """Get current datetime (UTC in live, backtest time in backtesting)."""
        if self.get_engine_type() == EngineType.BACKTESTING:
             dt = getattr(self.main_engine, "datetime", None) # Standard attribute in BacktestingEngine
             if dt and isinstance(dt, datetime):
                  return dt
             else:
                  self.write_log("Backtesting time not available via main_engine.datetime. Falling back to system time.", level=ERROR)
                  return datetime.now(timezone.utc) # Fallback, likely incorrect
        else:
             return datetime.now(timezone.utc)

    # --- Portfolio Data Accessors ---
    # --- (get_portfolio_position, get_portfolio_entry_price, get_portfolio_pnl, get_portfolio_total_pnl remain same as v3) ---
    def get_portfolio_position(self, strategy_name: str, vt_symbol: str) -> float:
        """Get current position size for a symbol tracked by the PortfolioEngine."""
        # ... (implementation remains the same as v3) ...
    def get_portfolio_entry_price(self, strategy_name: str, vt_symbol: str) -> float:
        """Get average entry price for the current position tracked by PortfolioEngine."""
        # ... (implementation remains the same as v3) ...
    def get_portfolio_pnl(self, strategy_name: str, vt_symbol: str) -> Tuple[float, float, float]:
        """Get (Trading PnL, Holding PnL, Total PnL) tracked by PortfolioEngine."""
        # ... (implementation remains the same as v3) ...
    def get_portfolio_total_pnl(self, strategy_name: str) -> float:
        """Get the aggregated Total PnL for the entire strategy portfolio."""
        # ... (implementation remains the same as v3) ...

    # --- Strategy Information Accessors ---
    # --- (get_all_strategy_class_names, get_strategy_class_parameters, get_strategy_parameters remain same as v3) ---
    def get_all_strategy_class_names(self) -> List[str]:
        """Return a list of names of all loaded strategy classes."""
        # ... (implementation remains the same as v3) ...
    def get_strategy_class_parameters(self, class_name: str) -> Optional[dict]:
        """Get the default parameters defined in a strategy class."""
        # ... (implementation remains the same as v3) ...
    def get_strategy_parameters(self, strategy_name: str) -> Optional[dict]:
        """Get the current parameters of a running strategy instance."""
        # ... (implementation remains the same as v3) ...

    # --------------------------------
    # Internal Helpers
    # --------------------------------
    # --- (call_strategy_func, put_strategy_update_event, write_log, send_email remain same as v3) ---
    def call_strategy_func(self, strategy: StrategyTemplate, func: Callable, params: Optional[Any] = None) -> Any:
        """Safely execute a method on a strategy instance, handling exceptions."""
        # ... (implementation remains the same as v3) ...
    def put_strategy_update_event(self, strategy: StrategyTemplate, removed: bool = False) -> None:
        """Publish an event notifying listeners of a strategy state change or removal."""
        # ... (implementation remains the same as v3) ...
    @virtual
    def write_log(self, msg: str, strategy: Optional[StrategyTemplate] = None, level: int = INFO) -> None:
        """Write a log message, prefixing with source and pushing to vnpy event log."""
        # ... (implementation remains the same as v3) ...
    def send_email(self, subject: str, msg: str, strategy: Optional[StrategyTemplate] = None) -> None:
        """Send an email notification through the MainEngine."""
        # ... (implementation remains the same as v3) ...

